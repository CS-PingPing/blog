---
sidebar_position: 3
title: Chapter3 메모리와 디스크의 핵심, 순차 논리
tags: [computer-architecture]
last_update:
  author: halang
---

이 포스트는 **한 권으로 읽는 컴퓨터 구조와 프로그래밍 (The Secret Life of Programs: Understand Computers)**의 Chapter3에 관한 내용이다.

## 들어가기 전

조합 논리 : 입력값에 의해서만 출력이 결정된다.
순차 논리 : 입력값과 현재 상태에 따라 회로의 출력과 다음 상태가 결정된다. 현재 상태를 저장하는 기억 소자가 있다.

## 시간 표현과 상태 기억

주기 함수를 사용해 시간을 측정할 수 있다.

### 메모리의 필요성

예를 들어, 3+2 라는 연산을 회로가 어떻게 처리할 수 있을까? 3, + , 2에 해당되는 데이터를 3가지 입력 장치를 통해 **동시에** 생성하고 연산의 결과가 나올 때까지 입력을 유지하는 방법을 생각할 수 있다.

하지만 3-2라는 연산을 수행하려는 경우에는 어떻게 해야할까? 덧셈과 달리 뺄셈과 나눗셈은 피연산자의 **순서**가 굉장히 중요하다. 실제 계산기의 경우 3-2라는 연산을 위해 3, -, 2라는 데이터를 **순차적**으로 입력한다. 따라서 내가 의도한 순서대로 연산이 가능하게 되며, 이렇게 생성된 데이터가 **메모리를 통해 회로 내에 유지된다.**

### 래치 - SR 래치

래치는 입력값을 외부로부터 꾸준히 입력받지 않더라도, 특정한 출력값을 유지할 수 있는 회로이다. 1비트 정보를 기억할 방법 중 하나이며 대표적으로 S-R래치와 D래치가 있다.

![래치](https://bugoverdose.github.io/static/9c4c401041cbe1d47f69c5670e1f7987/aeb78/or-gate-latch.png)

래치는 어떠한 값을 꾸준히 입력하지 않아도 이전 상태를 기억할 수 있다. 하지만 해당 회로만으로는 한번 out이 1이 되면 다시 0으로 바꿀 수 없다.

![and or 게이트 래치](https://bugoverdose.github.io/static/ce0eb5c7816f92b4addf0c24a6ac907c/a6d36/and-or-gate-latch.png)

하지만 AND-OR 게이트 래치를 사용하면 리셋을 함으로써(리셋이 1) out이 1이 되더라도 다시 0으로 바꿀 수 있다.

- S-R 래치

![S-R 래치](https://bugoverdose.github.io/static/7b643fcaceb7129332dd47c0b700ef88/98b6e/s-r-latch.png)

| $\overline{\text{set}}$ | $\overline{\text{reset}}$ |   $Q$    |   $\overline{\text{Q}}$    |
| :---------------------: | :-----------------------: | :------: | :------------------------: |
|            0            |             0             |    1     |             1              |
|            0            |             1             |    1     |             0              |
|            1            |             0             |    0     |             1              |
|            1            |             1             | $memory$ | $\overline{\text{memory}}$ |

S-R 래치는 1비트 메모리를 만드는 방법이다. S-R은 set-reset을 의미한다. $set$이 1이고 $reset$이 0이면 $Q$가 1이고, 반대라면 $Q$는 0이다.
$set$과 $reset$이 둘 다 1인 경우, $\overline{\text{set}}$과 $\overline{\text{reset}}$은 0이다. 따라서 $Q$와 $\overline{\text{Q}}$ 모두 1인데 서로 반대되어야 하는 값이 같게 나오므로 모순이다. 애초에 set을 하는데 reset도 한다는것이 말이 안된다.

또한 위 회로의 설계가 대칭적이기 때문에 $set$과 $reset$ 신호의 지연 시간이 거의 비슷하다.

### 클록

클록은 **시간의 경과를 알려주는 데이터 입력값 자체**를 의미한다.

우리는 아래와 같은 문제를 해결하기 위해 클록(clock)을 활용한다.

- 안정성 문제

  회로는 철저히 물리적인 특성을 지닌 기계이다. S-R 래치에서는 1이라는 데이터를 저장할 때 set에 1이 들어오고, 0으로 되돌릴 때 reset에 1이 들어온다. 그렇다면 만약 데이터를 변경할 생각이 없음에도 순간적으로 set이나 reset에 1이라는 입력값이 들어오면 어떻게 될까?

  이러한 가능성을 최소화하기 위해서 저장하려는 데이터에 대한 입력값 뿐만 아니라, **해당 정보를 사용하여 실제로 회로에 데이터를 저장하라고 명령을 내리는 입력값**도 함께 받아들여야 한다.

- 전파 지연

  입력값들에 부합하는 연산 결과가 게이트들을 지나 출력값으로 나올 때까지는 시간이 걸린다. 우리는 이를 전파 지연이라고 한다.

  회로가 안정적으로 동작하기 위해서는 하나의 작업을 수행했을 때마다 최악의 경우를 가정하고 예상되는 지연 시간의 최댓값만큼 다음 연산의 수행을 지연해야 한다.

![발진자](https://velog.velcdn.com/images%2Fyun2021%2Fpost%2Ff755cb8b-367b-4813-90d4-e99196b5f7d0%2F%EB%B0%9C%EC%8B%A0%EC%9E%90%20%EA%B7%B8%EB%A6%BC.png)

위 사진과 같이 주기적으로 0과 1사이의 출력을 오가는 회로 내의 부품을 발진자라고 한다. 인버터의 출력을 입력에 연결하여 주기적으로 값이 1이 되었을 때에만 특정 작업을 반복하여 수행하도록 설정할 수 있다. 이런 식의 연결을 되먹임(feedback)이라고 한다.

이 값이 진동하는 속도는 전파지연에 따라 결정되며 온도에 따라 달라진다. 보다 정확한 발진자를 적은 비용으로 효율적으로 만드는 방법은 크리스털(결정)을 활용하면 된다.

위와 같은 발전기를 통해 클록이라는 자극을 구현한다.

### 래치 - D래치

![D 래치](https://media.geeksforgeeks.org/wp-content/uploads/d_ltch.png)

D래치는 D(data)와 gate(enable)의 입력을 가진다. gate가 low라면 입력이 바뀌어도 출력이 변하지 않는다. gate가 high일 때 D값이 출력된다.

여기서의 문제는 gate가 1일때 D의 변화가 그대로 출력에 나타난다는 점이다. gate가 열려있을 때 input이 상태를 바꾼다면 문제가 생길 것이다.

### 플립플롭

플립플롭은 비트 단위로 데이터를 저장하는 회로 구조다.

![D 플립플롭](https://bugoverdose.github.io/static/828c51e178ab2af439055368e686c483/a6d36/d-flip-flop.png)

플립플롭은 edge에 의해 데이터 변화가 촉발되는 래치라고도 하며, D 플립플롭은 양의 edge에 의해 변화가 촉발된다. (논리 수준이 0에서 1로 바뀌는 순간 플립플롭의 출력이 바뀐다.)

![클록이 변할 때 D의 값이 저장된다](https://bugoverdose.github.io/static/67b2e6e9336cfced888421b1b4cc68ee/a6d36/edge-triggering-process.png)

위 회로도에서 굵은 색은 1에 해당되는 값의 전파가 흐르고 있음을 의미한다.

좌측 두 회로도를 보면 D의 값이 1로 고정되었을 때 clock이 0에서 1로 변하자 S의 값이 0에서 1로 변했다. 이는 플립플롭의 출력값이 1로 설정되었음을 의미한다.

우측의 두 회로도의 경우 D의 값이 0으로 고정되었을 때 clock이 0에서 1로 변하자 R의 값이 0에서 1로 변함을 알 수 있다. 이는 출력하는 값이 0으로 설정되었음을 의미한다.

D: 회로에 저장하고 싶은 데이터
clock이 0에서 1로 변하는 순간: D 입력값을 회로에 저장해라!

앞에서 보았던 D 래치는 gate가 열려있을 때 D의 값이 그대로 출력된다는 문제가 있었다.

![클록이 일정할 때 D는 영향력이 없다](https://bugoverdose.github.io/static/545905e6ff2ef894d2f911879ce9b420/a6d36/d-powerless.png)

반면, 플립플롭에서 클록이 고정되었을 때 D의 변화는 출력값에 영향을 미치지 않는다.

맨 왼쪽의 회로를 보자.

클록이 0으로 고정된 경우, D와 상관없이 항상 1을 출력함을 알 수 있다.

나머지 네 회로도를 보자.

클록이 1로 고정된 경우, D가 0에서 1로 혹은 1에서 0으로 변하여도 항상 결과값이 같다는 것을 확인할 수 있다.

따라서 클록이 0과 1 사이를 오가는 주기를 적절하게 설정함으로써 회로에 변화가 일어나는 시점을 온전히 통제할 수 있다. 이에 따라 우리는 예상되는 지연 시간의 최댓값만큼 다음 연산의 수행을 지연하면 된다.

물론, edge가 발생하는 시점에는 D의 값이 마음대로 변해서는 안된다.

### 레지스터

레지스터는 플립플롭의 여러 개의 그룹이다. 각 플립플롭은 클록을 공유하며 플립플롭당 한 비트의 정보를 저장할 수 있다. 즉, n개의 플립플롭으로 구성된 n-비트 레지스터는 n 비트의 2진 정보를 저장할 수 있다.

### 카운터

카운터는 근본적으로 여러 개의 2진 상태들이 미리 정해진 순서대로 진행되는 레지스터이다.

## References

[1] Jonathan E. Steinhart. The Secret Life of Programs: Understand Computers.  
[2] M. Morris Mano, Michael D. Ciletti. Digital Design

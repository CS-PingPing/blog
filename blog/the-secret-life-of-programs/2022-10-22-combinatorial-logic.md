---
slug: the-secret-life-of-programs/combinatorial-logic
title: Chap2 전자 회로의 조합 논리
authors: DevSlem
tags: [computer-architecture]
---

이 포스트는 **한 권으로 읽는 컴퓨터 구조와 프로그래밍 (The Secret Life of Programs: Understand Computers)**의 Chapter2에 관한 내용이다.

## 디지털 컴퓨터의 사례

이 내용은 생략한다.

### 아날로그와 디지털의 차이

아날로그와 디지털의 차이는 아래와 같다.

* 아날로그: **연속적인 (continuous)**
* 디지털: **이산적인 (discrete)**

### 하드웨어 크기의 중요성

하드웨어의 크기를 줄일 수록 아래와 같은 이점이 있다.

* 성능 향상
* 전력 소모 감소
* 발열 감소

그렇다면 왜 이러한 이점이 생길까? 컴퓨터는 전자의 이동을 통해 동작한다. 전자의 속도는 초당 30억미터로 이 보다 속도를 더 늘리는 것은 물리적으로 불가능하다. 따라서 하드웨어의 크기를 줄여 이동 거리를 줄임으로써 성능과 효율을 높일 수 있다.

### 디지털의 안정성

하드웨어를 작게 만들수록 속도와 효율은 좋아진다. 하지만 너무 작아질 경우 양자 세계에서 발생하는 간섭 문제가 발생한다. 양자가 굉장히 요동치고 민감하기 떄문에 연속적인 정확한 값을 측정하는 것은 불가능하다.

하지만 이산적인 값을 측정하는 디지털 방식은 훨씬 안정적이다. 그 이유는 판정 기준이 있기 때문이다. 판정 기준에 따라 값이 구분되는 전이 함수 떄문에 값이 요동칠 일이 없다. 이 때 이 판정 기준을 **문턱값 (threshold)**이라고 한다. 아래는 아날로그 신호를 디지털 신호로 변환하는 전이 함수 그림이다.

![](/img/the-secret-life-of-programs/fig2-6.png)

### 10진수 대신 비트를 사용하는 이유

10진수 보다 비트가 선호되는 이유는 아래와 같다.

* 사람과 달리 컴퓨터는 10개의 손가락이 없음
* 전이 함수를 10개의 문턱값으로 구분할 수 있는 간단한 방법이 없음

비트는 전이 함수의 하단부와 상단부에 의해 표현된다. 이 때 하단부 영역을 **차단 (cutoff)**, 상단부 영역을 **포화 (saturation)**이라고 부른다.

## 간단한 전기 이론 가이드

현대 컴퓨터는 전기를 통해 동작한다. 전기는 선을 통해 이동한다. 전기의 이동은 실제로는 전자의 흐름이 아니라 전자기 에너지 반응이 전파되는 현상이다. 전기 선은 내부에 있는 **도체**와 도체를 둘러싼 **부도체**로 구성되며, 전기의 흐름을 제어하는 장치를 **스위치**라고 한다.

전기의 3요소는 아래와 같다.

* 전압 $V$: 전기의 압력
* 전류 $I$: 전기 흐름의 양
* 저항 $R$: 전류 흐름의 방해 요소

위 세 요소의 관계를 나타낸 법칙을 **옴의 법칙**이라고 하며 수식은 아래와 같다.

$$
I = \dfrac{V}{R}
$$

## 비트를 처리하기 위한 하드웨어

비트를 처리하기 위한 하드웨어의 역사는 아래와 같은 순서로 발전하였다.

1. **릴레이 (relay)**: 스위치를 움직이기 위해 전자석을 사용하는 장치
2. **진공관**: 물체를 충분히 가열하면 전자가 튀어나오는 **열전자 방출 (thermionic)** 현상을 기반으로 함
3. **트랜지스터 (transistor)**: **반도체 (semiconductor)**를 사용
4. **직접 회로 (integrated circuit)**: 트랜지스터를 회로로 만든 장치


### 트랜지스터

트랜지스터는 반도체를 기반으로 한다. 반도체는 도체와 부도체 사이를 오갈 수 있는 물질이다. 트랜지스터에서 가장 중요한 두 가지 유형은 아래와 같다.

1. **쌍극 접합 트랜지스터 (BJT, bipolar junction transistor)**
2. **필드 효과 트랜지스터 (FET, field effect transistor)**

트랜지스터 제조 공정에서 **도핑 (doping)** 과정을 거치는데, 도핑은 반도체의 전기적, 물리적 특성을 변화시키는 것을 의미한다. 도핑을 통해 (+) 전하를 띠는 것과 마찬가지인 양공이 주가 되면 p형 반도체, (-) 전하를 띠는 자유전자가 주가 되면 n형 반도체라고 부른다.

**MOSFET (metal-oxide semiconductor field effect transistor)**은 FET의 일종으로 전력 소모가 적어 현대 컴퓨터 칩에서 가장 널리 쓰인다. **CMOS (complementary metal oxide semiconductor)**는 N채널과 P채널 MOSFET을 서로 보완하도록 한 쌍으로 묶어 사용하는 장치를 말한다.

## 논리 게이트

논리 게이트는 논리 연산을 처리하는 회로를 말한다. 아래는 **AND** 게이트, **OR** 게이트, **XOR** 게이트, **인버터** 게이트의 기호이다.

![](/img/the-secret-life-of-programs/fig2-26.png)

인버터 게이트에 동그라미가 없으면 **버퍼 (buffer)**로 입출력을 전달하는 용도로 사용된다.

그러나 실제로는 AND나 OR 게이트는 비교적 효율적이지 않기 떄문에 **NAND**나 **NOR** 게이트가 사용된다. 아래는 두 게이트의 기호로 AND와 OR 게이트에 not을 나타내는 원이 추가되었다.

![](/img/the-secret-life-of-programs/fig2-27.png)

NAND 게이트의 장점은 NAND 게이트만으로 AND, OR XOR, 인버터 게이트를 만들 수 있다는 것이다. NOR 역시 마찬가지이다.

### 이력 현상을 활용한 잡음 내성 향상

디지털 장치를 사용하면 판정 기준에 의해 잡음 내성을 얻을 수 있었다. 그러나 이것으로 충분하지는 않다. 입력 신호가 문턱값을 여러 번 왔다갔다하면 출력 신호에 작은 오류를 의미하는 **글리치 (glitch)** 현상이 발생할 수 있다.

이런 글리치를 **이력 현상 (hysteresis)**을 사용해 방지할 수 있다. 0에서 1로 가는 신호와 1에서 0으로 가는 신호에 대한 전이 함수를 다르게 하면 된다. 이력을 사용하는 가장 대표적인 게이트로 **슈미트 트리거**가 있다.

### 차동 신호

**차동 신호 (differential signaling)**는 잡음 내성을 얻는 또다른 방법이다. 측정하는 값이 서로 반전관계인 신호 쌍의 차이를 측정한다. 이를 수행하는 두 장치가 있다.

* **드라이버 (driver)**: 입력 신호를 두 반전관계 출력으로 변환
* **리시버 (receiver)**: 두 반전관계를 입력 받아 단일 신호로 변환

가끔 한 쌍의 전선이 서로 꼬여있는 것을 봤을 것이다. 이것이 차동 신호를 적용한 **연선 케이블링**이다. 

### 전파 지연

**전파 지연 (propagation delay)**은 입력의 변화가 출력에 영향을 미칠 때까지 걸리는 시간을 의미한다. 전파 지연은 논리 회로의 최대 속도를 제한하는 요소 중 하나이다. 회로가 제대로 동작하기 위해서는 worst-case 지연 시간을 감안해 설계해야한다.

## 게이트를 조합한 복잡한 회로

IC는 집적된 게이트 수에 따라 아래와 같이 구분된다.

* **SSI (small-scale integration)**
* **MSI (medium-scale integration)**
* **LSI (large-scale integration)**
* **VLSI (very-large-scale integration)**

### 가산기

#### 반가산기

먼저 매우 간단한 **반가산기**에 대해 알아보자. 두 비트를 더하는 진리표는 아래와 같다.

| $A$ | $B$ | $C$ | $S$ |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 0 |

$A$와 $B$는 입력, $C$는 올림, $S$는 합이다. 위 진리표를 보면 **올림 $C$는 AND**, **합 $S$는 XOR**임을 알 수 있다. 이에 대한 회로도는 아래와 같다.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Half_Adder.svg/440px-Half_Adder.svg.png)

#### 전가산기

반가산기는 올림을 처리하지 못한다. **전가산기**는 하위의 자리올림수 출력을 상위 자리올림수 입력에 연결함으로써 임의의 자리수의 2진수 덧셈을 처리한다. 진리표는 아래와 같다.

|$A$|$B$|$C_{in}$|$C_{out}$|$S$|
|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|0|
|0|0|1|0|1|
|0|1|0|0|1|
|0|1|1|1|0|
|1|0|0|0|1|
|1|0|1|1|0|
|1|1|0|1|0|
|1|1|1|1|1|

$A$와 $B$는 입력, $C_{in}$은 자리올림수 입력, $C_{out}$은 자리올림수 출력, $S$는 합이다. 아래는 전가산기의 회로도이다.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Full-adder_logic_diagram.svg/2560px-Full-adder_logic_diagram.svg.png)

#### 리플 자리올림 가산기

전가산기를 연결하면 여러 비트를 더할 수 있다. 가장 간단한 방식은 각각의 전가산기가 자리올림수 입력 $C_{in}$으로 직전 자리올림수 출력 $C_{out}$을 받는 것이다. 이를 **리플 자리올림 가산기**라고 한다.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/4-bit_ripple_carry_adder.svg/2560px-4-bit_ripple_carry_adder.svg.png)

#### 올림 예측 가산기

리플 자리올림 가산기 방식은 비효율적이다. 이전 자리올림수에 대한 전파 지연이 발생하기 때문이다. **올림 예측 가산기**는 올림을 예측함으로써 이러한 전파 지연을 제거할 수 있다. 이를 수식적으로 한번 알아보자.

먼저, $i+1$번째 비트의 올림 입력 $C_{i+1}$은 아래와 같이 계산된다.

$$
C_{i+1} = \text{($A_i$ AND $B_i$) OR ($A_i$ AND $C_i$) OR ($B_i$ AND $C_i$)}
$$

여기서 문제는 $C_{i+1}$을 계산하기 위해 $C_i$가 필요해 전파 지연이 발생한다는 점이다. 이는 $C_{i+2}$에 대해서도 마찬가지이다.

$$
C_{i+2} = \text{($A_{i+1}$ AND $B_{i+1}$) OR ($A_{i+1}$ AND $C_{i+1}$) OR ($B_{i+1}$ AND $C_{i+1}$)}
$$

그러나 위 수식을 보면 한가지 사실을 알 수 있다. $C_{i+1}$은 $C_{i}$에 의해 표현되고, $C_{i+2}$는 $C_{i+1}$에 의해 표현된다. 즉, 재귀적 관계이다. 따라서 $C_{i+2}$는 아래와 같이 $C_i$에 의해 표현될 수 있다.

$$
\begin{align*}
    C_{i+2} &= \text{($A_{i+1}$ AND $B_{i+1}$)} \\
    & \text{OR} \Big(\text{$A_{i+1}$ AND } \big(\text{($A_i$ AND $B_i$) OR ($A_i$ AND $C_i$) OR ($B_i$ AND $C_i$)}\big) \Big) \\
    & \text{OR} \Big(\text{$B_{i+1}$ AND } \big(\text{($A_i$ AND $B_i$) OR ($A_i$ AND $C_i$) OR ($B_i$ AND $C_i$)}\big) \Big)
\end{align*}
$$

위 수식을 통해 알 수 있듯이 회로를 위와 같이 구성하면 AND와 OR 게이트가 많아져 회로가 복잡해지긴 하지만, 이전 자리올림수를 기다릴 필요가 없어 전파 지연을 획기적으로 줄일 수 있다. 아래는 올림 예측 가산기의 회로도이다.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/04/4-bit_carry_lookahead_adder.svg/2560px-4-bit_carry_lookahead_adder.svg.png)

### 디코더

**디코더 (decoder)**는 인코딩된 수를 개별 비트의 집합으로 만들어준다. 예를 들어 3:8 디코더가 있다고 하자. 3:8 디코더는 입력이 3개, 출력이 8개이다.

![](/img/the-secret-life-of-programs/fig2-44.png)

예를 들어 입력이 000이면 $Y_0$가 참이다. 001이면 $Y_1$이 참이다. 3비트로 표현된 2진수는 최대 8개의 수를 표현할 수 있기 때문에 위와 같이 디코딩 할 수 있다. 아래는 위 3:8 디코더의 진리표이다.

|$S_2$|$S_1$|$S_0$||$Y_0$|$Y_1$|$Y_2$|$Y_3$|$Y_4$|$Y_5$|$Y_6$|$Y_7$|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0||**1**|0|0|0|0|0|0|0|
|0|0|1||0|**1**|0|0|0|0|0|0|
|0|1|0||0|0|**1**|0|0|0|0|0|
|0|1|1||0|0|0|**1**|0|0|0|0|
|1|0|0||0|0|0|0|**1**|0|0|0|
|1|0|1||0|0|0|0|0|**1**|0|0|
|1|1|0||0|0|0|0|0|0|**1**|0|
|1|1|1||0|0|0|0|0|0|0|**1**|

### 디멀티플렉서

**디멀티플렉서 (demultiplexer)**는 입력을 몇가지 출력 중 한 곳으로 전달하는 역할을 하며 보통 디먹스라고 줄여서 부른다. 디먹스는 디코더를 사용해 구현된다.

![](/img/the-secret-life-of-programs/fig2-45.png)

위 그림을 보면 입력 신호 $D$를 $S_0$와 $S_1$에 의해 $Y_0$ ~ $Y_3$ 중 한 곳으로 전달함을 알 수 있다. 아래는 디먹스의 기호이다.

![](/img/the-secret-life-of-programs/fig2-46.png)

### 실렉터

**실렉터 (selector)**는 반대로 여러 개의 입력 중의 하나를 선택하는 장치로 멀티플렉서라고도 한다. 멀티플렉서는 보통 먹스라고 부른다. 역시 디코더를 사용해 구현된다.

![](/img/the-secret-life-of-programs/fig2-47.png)

위 그림을 보면 $S_0$와 $S_1$에 의해 입력 신호 $D_0$ ~ $D_3$ 중 하나를 선택해 $Y$로 출력하고 있음을 알 수 있다. 아래는 실렉터의 기호이다.

![](/img/the-secret-life-of-programs/fig2-48.png)

## Summary

* 아날로그는 연속적, 디지털은 이산적
* 하드웨어 크기를 줄일 수록 성능과 효율이 좋아짐
* 아날로그 방식보다 디지털 방식이 훨씬 안정적
* 디지털 방식에는 이산적인 값을 측정하는 판정 기준이 있음
* 10진수 대신 비트를 사용하는 이유는 구분이 간단하기 떄문
* 옴의 법칙: $I = V / R$
* 트랜지스터는 반도체를 사용
* 트랜지스터는 크게 BJT와 FET가 있음
* 현대 컴퓨터는 MOSFET을 주로 사용
* 논리 게이트는 논리 연산을 처리하는 회로
* AND나 OR보다는 NAND나 NOR 게이트를 사용
* NAND 혹은 NOR 게이트 만으로 모든 게이트를 표현 가능
* 이력 현상과 차동 신호를 통해 잡음 내성을 향상할 수 있음
* 전파지연은 입력의 변화가 출력에 영향을 미칠 때까지 걸리는 시간으로 논리 회로의 최대 속도를 제한하는 요소 중 하나임
* 가산기에는 반가산기와 전가산기가 있으며 전가산기는 올림을 처리할 수 있음
* 리플 자리올림 가산기는 전가산기를 연결한 가장 간단한 방식으로 직전 자리올림수의 출력을 입력 받기 때문에 전파 지연이 발생함
* 올림 예측 가산기는 올림을 예측함으로써 전파 지연을 제거
* 디코더는 인코딩된 수를 개별 비트의 집합으로 만듦
* 디멀티플렉서는 입력을 몇가지 출력 중 한 곳으로 전달
* 실렉터는 여러 개의 입력 중 하나를 선택

## References

[1] Jonathan E. Steinhart. The Secret Life of Programs: Understand Computers.  
[2] Wikipedia. [Adder (electronics)](https://en.wikipedia.org/wiki/Adder_(electronics)).  